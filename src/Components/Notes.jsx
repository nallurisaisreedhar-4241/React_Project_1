
//! 1st
// //!Notes.jsx for the AiNotes

import React, { useState, useRef, useContext, useEffect } from "react";
import {
  ContentCopy, Delete, Edit, Star, StarBorder,
  Fullscreen, FullscreenExit, Close, Share,
  Mic, Stop, Image
} from "@mui/icons-material";
import "./Notes.css";
import { Services } from "./Services/Services";
import { ContextApi } from "./Context/Context";
import { format } from "date-fns";

const Notes = ({ notes, setNotes }) => {
  const [modalNote, setModalNote] = useState(null);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [isRecording, setIsRecording] = useState(false);
  const [recordingProgress, setRecordingProgress] = useState(0);
  const [recordedTime, setRecordedTime] = useState(0);
  const recognitionRef = useRef(null);
  const [selectedLanguage, setSelectedLanguage] = useState("en-US");
  const [textNote, setTextNote] = useState("");
  const { globaldata } = useContext(ContextApi);
  let progressInterval;

  useEffect(() => {
    if (globaldata?.id) {
      fetchUserNotes(globaldata.id);
    }
  }, [globaldata?.id]);

  const fetchUserNotes = async (userId) => {
    try {
      const userNotes = await Services.getNotes(userId);
      setNotes(userNotes);
    } catch (error) {
      console.error("Error fetching notes:", error);
    }
  };

  const formatDateTime = (isoString) => {
    return format(new Date(isoString), "MMMM d, yyyy - hh:mm a");
  };
  const addTextNote = async () => {
    if (textNote.trim() === "") return;
    if (!globaldata?.id) {
      alert("User ID missing. Please log in.");
      return;
    }

    let newNote = {
      title: "New Text Note",
      text: textNote,
      date: formatDateTime(new Date().toISOString()),
      favorite: false,
      userId: globaldata.id,
    };

    try {
      let savedNote = await Services.addNotes(globaldata.id, newNote);
      setNotes([...notes, savedNote]); // Backend will return the note with its autogenerated ID
      setTextNote(""); // Clear input after adding
    } catch (error) {
      console.error("Error adding note:", error);
    }
  };


  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text);
    alert("Copied to clipboard!");
  };

  const deleteNote = async (id) => {
    await Services.deleteNote(id);
    setNotes((prevNotes) => prevNotes.filter((note) => note.id !== id));
  };

  const renameNote = (id, value, field) => {
    setNotes((prevNotes) =>
      prevNotes.map((note) =>
        note.id === id ? { ...note, [field]: value } : note
      )
    );
  };
  const toggleFavorite = async (id) => {
    const updatedNote = notes.find((note) => note.id === id);
    if (!updatedNote) return;

    const newFavoriteStatus = !updatedNote.favorite;
    setNotes(notes.map((note) => (note.id === id ? { ...note, favorite: newFavoriteStatus } : note)));

    try {
      await Services.updateNote(id, { favorite: newFavoriteStatus });
    } catch (error) {
      console.error("Error updating favorite status:", error);
    }
  };



  const shareNote = (text) => {
    if (navigator.share) {
      navigator.share({ text });
    } else {
      alert("Sharing not supported");
    }
  };

  const startRecording = () => {
    if (!globaldata?.id) {
      alert("User ID missing. Please log in to record notes.");
      return;
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      alert("Speech recognition is not supported in this browser.");
      return;
    }

    recognitionRef.current = new SpeechRecognition();
    recognitionRef.current.continuous = false;
    recognitionRef.current.interimResults = false;
    recognitionRef.current.lang = selectedLanguage; // Set selected language

    setRecordingProgress(0);
    setRecordedTime(0);
    setIsRecording(true);

    let elapsedTime = 0;
    const maxTime = 60;

    progressInterval = setInterval(() => {
      elapsedTime++;
      setRecordingProgress((elapsedTime / maxTime) * 100);
      setRecordedTime(elapsedTime);
      if (elapsedTime >= maxTime) {
        stopRecording();
      }
    }, 1000);

    recognitionRef.current.onresult = async (event) => {
      const transcript = event.results[0][0].transcript;

      let newNote = {
        title: "New Audio Note",
        text: transcript,
        date: formatDateTime(new Date().toISOString()),
        favorite: false,
        userId: globaldata.id,
      };

      try {
        let savedNote = await Services.addNotes(globaldata.id, newNote);
        setNotes((prevNotes) => [...prevNotes, savedNote]);
      } catch (error) {
        console.error("Error saving audio note:", error);
      }

      stopRecording();
    };

    recognitionRef.current.onerror = (event) => {
      console.error("Speech recognition error:", event.error);
      stopRecording();
    };

    recognitionRef.current.onend = () => {
      stopRecording();
    };

    recognitionRef.current.start();
  };

  // Stop Recording Function
  const stopRecording = () => {
    if (recognitionRef.current) {
      recognitionRef.current.stop();
    }
    setIsRecording(false);
    clearInterval(progressInterval);
  };

  return (
    <div className="notes-container">
      {notes.length > 0 ? (
        notes.map((note) => (
          <div key={note.id} className={`notecard ${note.favorite ? "favorite" : ""}`} onClick={() => setModalNote(note)}>
            <h3>{note.title || "Untitled Note"}</h3>
            <p>{note.text}</p>
            <span>{note.date || "No Date"}</span>
            <div className="note-actions">
              <button onClick={(e) => { e.stopPropagation(); copyToClipboard(note.text); }}><ContentCopy /></button>
              <button onClick={(e) => { e.stopPropagation(); console.log("Clicked delete for note:", note); deleteNote(note.id); }}><Delete /></button>

              <button onClick={(e) => {
                e.stopPropagation();
                const newTitle = prompt("Enter new title", note.title);
                if (newTitle) renameNote(note.id, newTitle);
              }}><Edit /></button>
              <button onClick={(e) => { e.stopPropagation(); toggleFavorite(note.id); }}>
                {note.favorite ? <Star /> : <StarBorder />}
              </button>
            </div>
          </div>
        ))
      ) : (
        <p>No notes available</p>
      )}

      {modalNote && (
        <div className={`modal ${isFullscreen ? "fullscreen" : ""}`}>
          <div className="modal-header">
            <button onClick={() => setIsFullscreen(!isFullscreen)}>
              {isFullscreen ? <FullscreenExit /> : <Fullscreen />}
            </button>
            <div className="modal-header-right">
              <button onClick={() => toggleFavorite(modalNote.id)}>
                {modalNote.favorite ? <Star /> : <StarBorder />}
              </button>
              <button onClick={() => shareNote(modalNote.text)}><Share /></button>
              <button onClick={() => setModalNote(null)}><Close /></button>
            </div>
          </div>
          <div className="modal-content">
            <input
              type="text"
              value={modalNote.title || "Untitled Note"}
              onChange={(e) => renameNote(modalNote.id, e.target.value, "title")}
              placeholder="Enter Title"
              className="modal-title"
            />
            <textarea
              value={modalNote.text}
              onChange={(e) => renameNote(modalNote.id, e.target.value, "text")}
              placeholder="Enter Description"
              className="modal-text"
            />
            <input
              type="date"
              value={modalNote.date || ""}
              onChange={(e) => renameNote(modalNote.id, e.target.value, "date")}
              className="modal-date"
            />
          </div>

        </div>
      )}

      <div className="recording-bar">
        <div className="icon-button">
          <button className="tooltip" onClick={addTextNote}>
            <Edit />
            <span className="tooltip-text">Text Note</span>
          </button>
          <button className="tooltip">
            <Image />
            <span className="tooltip-text">Add Image Note</span>
          </button>
        </div>
        <input
          type="text"
          className="text-input"
          placeholder="Type your note and press Enter..."
          value={textNote}
          onChange={(e) => setTextNote(e.target.value)}
          onKeyDown={(e) => e.key === "Enter" && addTextNote()}
        />

        <div className="recording-controls">
          <select
            value={selectedLanguage}
            onChange={(e) => setSelectedLanguage(e.target.value)}
            className="language-dropdown"
          >
            <option value="en-US">English</option>
            <option value="hi-IN">Hindi</option>
            <option value="te-IN">Telugu</option>
            <option value="ta-IN">Tamil</option>
            <option value="kn-IN">Kannada</option>
            <option value="ml-IN">Malayalam</option>
            <option value="mr-IN">Marathi</option>
            <option value="bn-IN">Bengali</option>
            <option value="pa-IN">Punjabi</option>
            <option value="gu-IN">Gujarati</option>
          </select>
          {isRecording ? (
            <>
              <button className="record" onClick={stopRecording}><Stop /> Stop Recording</button>
              <input className="recording-range" type="range" min="0" max="100" value={recordingProgress} readOnly />
              <p>{recordedTime} sec</p>
            </>
          ) : (
            <button className="record" onClick={startRecording}><Mic /> Start Recording</button>
          )}
        </div>
      </div>
    </div>
  );
};

export default Notes;
